\documentclass[12pt,a4paper]{article}
\usepackage{amsmath,amssymb,amsthm,amsfonts}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{listings}
\usepackage{xcolor}

\geometry{margin=1in}
\pagestyle{fancy}
\fancyhead[L]{Photonic App Technical Report}
\fancyhead[R]{Development \& Physics}

\title{\textbf{Development and Physics-Based Modeling of the Photonic Computing Web Application}}
\author{NeuroMorph Photonic Systems Division}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{derivation}{Derivation}

\lstset{basicstyle=\ttfamily\footnotesize, breaklines=true}

\begin{document}

\maketitle

\begin{abstract}
This report details the development of a high-performance web application for simulating and designing photonic computing systems. We present the software architecture comprising a Flask-based backend and a dynamic frontend, alongside rigorous derivations of the physics engines implemented. Key features include a custom Finite Difference Frequency Domain (FDFD) solver for optical modes, Tin-Film Lithium Niobate (TFLN) modulator modeling, and a novel API-based GitHub integration mechanism developed to operate without local Git clients.
\end{abstract}

\tableofcontents
\newpage

\section{Application Architecture}

The Photonic Computing Web Application is designed as a modular, full-stack system to democratize access to advanced photonic design tools.

\subsection{Backend System (Flask/Python)}
The core logic resides in a Python-based Flask server (`app.py`), which orchestrates several specialized modules:
\begin{enumerate}
    \item \textbf{Physics Engines}: Custom implementations for Matrix Multiplication (`photonic\_core.py`), FFT, and Resonator physics.
    \item \textbf{Integration Interfaces}: Modules for PCIe simulation (`pcie\_interface.py`) and Hybrid FPGA coprocessing.
    \item \textbf{File Parsers}: Custom parsers for Gerber (PCB) and G-Code (CNC) files for manufacturing visualization.
\end{enumerate}

\subsection{Frontend Visualization}
The user interface (`index.html`) utilizes HTML5 Canvas for high-performance rendering of engineering assets:
\begin{itemize}
    \item \textbf{Gerber Viewer}: Renders multi-layer PCB designs by parsing coordinate primitives.
    \item \textbf{Real-Time Plotting}: Visualizes TFLN performance metrics and FEA mode profiles.
\end{itemize}

\section{Finite Element Analysis (FEA) Engine}

A critical component of the application is the browser-based simulation of optical waveguides. We derived a Finite Difference Frequency Domain (FDFD) solver to solve the scalar Helmholtz equation.

\subsection{Mathematical Formulation}
For a quasi-TE mode in a waveguide defined by refractive index distribution $n(x,y)$, the wave equation is:
\begin{equation}
\nabla_\perp^2 E_x + [k_0^2 n^2(x,y) - \beta^2] E_x = 0
\end{equation}
where $k_0 = 2\pi/\lambda$ is the free-space wavenumber and $\beta = k_0 n_{eff}$ is the propagation constant.

\subsection{Discrete Approximation}
We employ a central difference scheme on a 2D grid $(i,j)$ with spacing $h_x, h_y$:
\begin{derivation}[5-Point Stencil]
\begin{equation}
\frac{E_{i+1,j} - 2E_{i,j} + E_{i-1,j}}{h_x^2} + \frac{E_{i,j+1} - 2E_{i,j} + E_{i,j-1}}{h_y^2} + k_0^2 n_{i,j}^2 E_{i,j} = \beta^2 E_{i,j}
\end{equation}
\end{derivation}
This transforms the partial differential equation into a sparse eigenvalue problem $\mathbf{A}\mathbf{x} = \lambda \mathbf{x}$, which is solved numerically to obtain the effective index $n_{eff}$ and mode profiles displayed in the app.

\section{TFLN Physics Modeling}

\subsection{Electro-Optic Pockels Effect}
The app models Thin-Film Lithium Niobate modulators using the anisotropic Pockels effect. The refractive index change is derived as:
\begin{equation}
\Delta n = -\frac{1}{2} n_e^3 r_{33} \frac{V}{d} \Gamma
\end{equation}
This allows for the precise calculation of the half-wave voltage ($V_\pi$):
\begin{equation}
V_\pi = \frac{\lambda d}{n_e^3 r_{33} \Gamma L}
\end{equation}
Our implementation yields a theoretical $V_\pi \approx 2.74$ V for the designed parameters, validating the high-efficiency claims of the platform.

\section{Custom GitHub Integration}

To meet deployment constraints (specifically, no local Git installation), we developed a custom Python-based uploader (`github\_uploader.py`).

\subsection{Rest API Implementation}
Instead of standard `git push` commands, the system interacts directly with the GitHub REST API:
\begin{itemize}
    \item \textbf{File Discovery}: Recursive directory walking with `.gitignore` parsing.
    \item \textbf{Content Encoding}: Files are Base64 encoded and sent via `PUT` requests to `https://api.github.com/repos/{owner}/{repo}/contents/{path}`.
    \item \textbf{Concurrency}: The web app handles uploads in background threads to maintain UI responsiveness.
\end{itemize}

\subsection{Simulation Mode}
An "Offline Mode" was implemented to facilitate testing and demonstration without modifying live repositories. This required abstracting the network layer to simulate latency and API responses.

\section{Conclusion}
The Photonic Computing Web Application represents a conversion of rigorous physics modeling and modern software engineering. By embedding custom FEA solvers and physics-based component models directly into an interactive web platform, we provide a powerful tool for next-generation photonic chip design.

\end{document}
